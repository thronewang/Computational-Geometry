形形色色的凸包算法之后
我们最后以这个第二个版本的
Divide-and-Conquer算法为例来讨论几个
稍微细节性的问题
首先第一个问题
就是所谓的Generacy的问题——一般化
我们所谓的一般化
就是指这些顶点
或者说我们给定的这些集合中的点
没有什么退化的情况
什么叫退化的情况呢
很多
比如说在我们这里头我们经常假设
不会有三个共线的点
不会有三点同时共线
也不会呢
比如像最后的那个算法
不会由两个点是位于
同一条垂直线上
比如它们的x值相等
以至于在你开始做x-sorting的时候
有可能会出现歧义
这种情况
我们都称为是Degeneracy的情况
退化的情况
而否则的话呢
我们也称这种的Point set is in general position
所有这些点都是位于正常的位置的
而不是特殊的位置的
那么我们前面讲过
作为老师的特权
在课堂上可以说
我不考虑这些问题
但实际上在实际工作中
这是非常非常重要的
其实无论我是在清华
还是在这个慕课的课堂上
在考察学生最终的实验的时候
这个方面往往还是
非常非常重要的一个方面
所以你不可以掉以轻心
你自己做测试的时候
不妨也可以这么做一做
比如你就可以去做
三个点是共线的
可以故意地构造
两个点是在同一条垂直线
或者水平线上的
甚至在我们后面还会考虑到
有什么四点共圆等等情况
当然如果你要想让
一个这方面的算法崩溃的话
我的老师当年曾经教过我
一个最简单的办法
就是你手动输入
然后在同一个位置上
连续的点两次鼠标
据我的经验，70%的程序
都会立即崩溃掉
同样是因为
我们这个课程课时的问题
我们没有对这个做进一步的讨论
跟前面我们所讲到的这个话题是一样的
我们建议你去阅读
我提供的这部分的讲义
在我们这一章的后面附加的部分
专门有一节
对种种的这些退化情况
有一些建议的方法
一些相对比较简明
比较实用的方法
当然更多的这方面的讨论的方法
建议你去看更多的参考书
比如我翻译的那本CGAA
那本计算几何经典的教材里头
也关于这个给出了很多
非常有用的
也是很有效的相关的解决方法
总而言之
对付退化问题
是我们共同的一个大敌
你在实际应用中
是不得不把这个问题妥善地解决的
关于我们刚才讲过的这个
Divide-and-Conquer算法的本身
我们也可以发现
它也有某些方面的不足
比如我们曾经前面讲过Jarvis march
虽然它的最坏的时间复杂度
是n平方的
但它有一个
可以期待的
很好的情况
在它的best case中
它只需要线性的时间
我们讲过一般而言
那个算法是取决于
它的output size
所以我们也称之为output-sensitive的
那么这样一种性质
或者这种现象
如果会出现在
我们这个算法的输入中
它又会怎么样呢
那我们会发现
这个算法表现得并不是很好
因为我们知道
它会一根筋式地
一上来首先做一个
沿x方向的presorting
而这个时间复杂度
我们说已经注定了是nlogn的
也就是说一上来
就要花费这么多时间
可实际上我们会发现
你其实远远用不着这么多时间
包括你的merge
你完全也许可以通过其他的一些技巧
来做到这一件事
比如我们来考虑
这样的两个凸包
如果我们要讲它们合并的话
刚才那个算法会怎么样呢
我们会发现它确实会亦步亦趋地
像刚才我们建议的那样
把这边的最右侧的那个点
和这边的最左侧那个点
先拉上手
先缝上第一条线
然后呢通过向上的zig-zag
不断地之字形地前行
最后找到这个（英文）
对称地呢
它也会沿着向下这个方向
做一系列的zig-zag
最后找到这个lower tangent
中规中矩是这个算法的特点
其实你不难发现
在这种情况下
我们完全可以有些方法
可以尽快地找到这两条切线
并且通过这样一个shortcut
把它们merge起来